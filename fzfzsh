fzf-custom-preview () {
    ext=$1:t:e
    if [ -d $1 ] && eza --all --classify --color=always -T $1 && return
    case "$ext" in
        pdf|Pdf|PDF)
            pdftotext -nodiag -nopgbrk $1 - | bat --style=numbers --color=always --line-range :500
            ;;
        rar|Rar|RAR)
            lsar $1
        ;;
        *)
            (more --style=numbers --color=always --line-range :500 $1|| tree --charset=utf-8 -C $1) 2> /dev/null | head -200
            ;;
        esac
    return
}

zle -N fzf-custom-preview

fzf-redraw-prompt() {
    local precmd
    for precmd in $precmd_functions; do
        $precmd
    done
    zle reset-prompt
}
zle -N fzf-redraw-prompt

accept-line() {
    if [[ -z $BUFFER ]]; then
        zle -I
        l
    else
        zle ".$WIDGET"
    fi
}

zle -N accept-line

function man() {
    if [ "$#" -gt 0 ]; then
        /bin/man $1 | col -bx | bat --language=man --plain --color always --theme="Monokai Extended"
        return
    fi

    batman="/bin/man {1} | col -bx | bat --language=man --plain --color always --theme=\"Monokai Extended\""
    /bin/man -k . | sort \
        | awk -v cyan=$(tput setaf 6) -v blue=$(tput setaf 4) -v res=$(tput sgr0) -v bld=$(tput bold) '{ $1=cyan bld $1; $2=res blue;} 1' \
        | fzf  \
        -q "'$1" \
        --ansi \
        --tiebreak=begin \
        --prompt=' Man > '  \
        --preview-window 'up,50%,rounded,<50(up,85%,border-bottom)' \
        --preview "${batman}" \
        --bind "enter:become(man {1})" 
    zle reset-prompt
}

function dnf() {
    if [ "$#" -gt 0 ]; then
        `which dnf` "$@"
    else
        ~/.dnf.fzf
    fi
}


# FF browse history

h() {
    local cols sep google_history open
    cols=$((COLUMNS / 3))
    sep='{::}'

    if [ "$(uname)" = "Darwin" ]; then
        brows_hist_db="$HOME/Library/Application Support/Google/Chrome/Default/History"
        open=open
    else
        cp -f $HOME/.mozilla/firefox/*/places.sqlite /tmp/h
        open=xdg-open
    fi
    sqlite3 -separator $sep /tmp/h \
        "select datetime(v.visit_date/1000000, 'unixepoch'), substr(p.title, 1, $cols), p.url\
        from moz_places p \
        JOIN moz_historyvisits v ON p.id = v.place_id \
        GROUP BY p.url\
        ORDER BY last_visit_date DESC" |
        awk -F $sep '{printf "%s  \x1b[36m%s  \x1b[m%s\n", $1, $2, $3}' |
        sed -E 's/\x1b\[[0-9;]+m  //g' |
        fzf --ansi --multi |
        xargs $open >/dev/null 2>/dev/null
}

# #
# # Google Chrome
# # c - browse chrome history
# h() {
#     local cols sep google_history open
#     cols=$((COLUMNS / 3))
#     sep='{::}'

#     if [ "$(uname)" = "Darwin" ]; then
#         google_history="$HOME/Library/Application Support/Google/Chrome/Default/History"
#         open=open
#     else
#         google_history="$HOME/.config/google-chrome/Default/History"
#         open=xdg-open
#     fi
#     cp -f "$google_history" /tmp/h
#     sqlite3 -separator $sep /tmp/h \
#         "select substr(title, 1, $cols), url
#   from urls order by last_visit_time desc" |
#         awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}' |
#         fzf --ansi --multi | sed 's#.*\(https*://\)#\1#' | xargs $open >/dev/null 2>/dev/null
# }

# b - browse chrome bookmarks
b() {
    bookmarks_path=~/Library/Application\ Support/Google/Chrome/Default/Bookmarks

    jq_script='
  def ancestors: while(. | length >= 2; del(.[-1,-2]));
  . as $in | paths(.url?) as $key | $in | getpath($key) | {name,url, path: [$key[0:-2] | ancestors as $a | $in | getpath($a) | .name?] | reverse | join("/") } | .path + "/" + .name + "\t" + .url'

    jq -r "$jq_script" <"$bookmarks_path" |
        sed -E $'s/(.*)\t(.*)/\\1\t\x1b[36m\\2\x1b[m/g' |
        fzf --ansi |
        cut -d$'\t' -f2 |
        xargs open
}

jump() {
    local preview_cmd="ls {2..}"
    if command -v exa &> /dev/null; then
        preview_cmd="exa -l {2}"
    fi

    if [[ $# -eq 0 ]]; then
                local output="$(autojump -s | sort -k1gr | awk -F : '$1 ~ /[0-9]/ && $2 ~ /^\s*\// {print $1 $2}' | fzf --height 100% --reverse --inline-info --preview "$preview_cmd" --preview-window down:50% | cut -d$'\t' -f2- | sed 's/^\s*//')"
                if [[ -d "${output}" ]]; then
                    if [ -t 1 ]; then  # if stdout is a terminal, use colors
                            echo -e "\\033[31m${output}\\033[0m"
                    else
                            echo -e "${output}"
                    fi
                    chdir "${output}"
                    fzf-redraw-prompt
                fi
    else
        cd $(autojump $@)
    fi
}

function rgfzf() {
    local QF QR QM
    QF="$(mktemp "${TMPDIR:-/tmp}/rgfzf.qf.XXXXXX")" || return 1
    QR="$(mktemp "${TMPDIR:-/tmp}/rgfzf.qr.XXXXXX")" || { rm -f "$QF"; return 1; }
    QM="$(mktemp "${TMPDIR:-/tmp}/rgfzf.qm.XXXXXX")" || { rm -f "$QF" "$QR"; return 1; }
    trap 'rm -f -- "$QF" "$QR" "$QM"' EXIT INT TERM HUP
  print -r -- f > "$QM"

  local INITIAL_QUERY="${*:-}"
  local ret

  # Base commands (keep them simple; no nested quoting)
  local FD_CMD='fd --type f --hidden --follow --exclude .git .'
  local RG_CMD='rg --column --line-number --no-heading --color=always --smart-case'

  ret="$(
    eval "$FD_CMD" | fzf --ansi \
      --query "$INITIAL_QUERY" \
      --prompt 'files> ' \
      --header '╱ CTRL-F (files mode) ╱ CTRL-R (ripgrep mode) ╱' \
      --color "hl:-1:underline,hl+:-1:underline:reverse" \
      --delimiter : \
      --preview '[[ "{1}" == *:*:* ]] && bat --color=always {1} --highlight-line {2} || bat --color=always --style=numbers --line-range :200 {1} 2>/dev/null || sed -n "1,200p" {1}' \
      --preview-window 'up,60%,border-bottom,+{2}+3/3,~3' \
      \
      --bind "start:unbind(change)" \
      --bind "change:reload(sh -c 'fq=\$(cat \"$QF\" 2>/dev/null); if [ -n \"\$fq\" ]; then fd --type f --hidden --follow --exclude .git -g \"*\$fq*\" -0 . | xargs -0 rg --column --line-number --no-heading --color=always --smart-case -- \"\$1\"; else rg --column --line-number --no-heading --color=always --smart-case -- \"\$1\"; fi' _ {q} || true)" \
      \
      --bind "ctrl-r:transform:sh -c 'm=\$(cat \"$QM\" 2>/dev/null); if [ \"\$m\" = r ]; then echo ignore; else echo \"execute-silent(echo {q} > $QF; echo r > $QM)+transform-query(cat $QR 2>/dev/null)+change-prompt(ripgrep> )+disable-search+rebind(change)+reload(sh -c \\\"fq=\\\\\\\$(cat $QF 2>/dev/null); if [ -n \\\\\\\"\\\\\\\$fq\\\\\\\" ]; then fd --type f --hidden --follow --exclude .git -g \\\\\\\"*\\\\\\\$fq*\\\\\\\" -0 . | xargs -0 rg --column --line-number --no-heading --color=always --smart-case -- \\\\\\\"\\\\\\\$1\\\\\\\"; else rg --column --line-number --no-heading --color=always --smart-case -- \\\\\\\"\\\\\\\$1\\\\\\\"; fi\\\" _ {q} || true)\"; fi'" \
      \
      --bind "ctrl-f:transform:sh -c 'm=\$(cat \"$QM\" 2>/dev/null); if [ \"\$m\" = f ]; then echo ignore; else echo \"execute-silent(echo {q} > $QR; echo f > $QM)+transform-query(cat $QF 2>/dev/null)+change-prompt(files> )+enable-search+unbind(change)+reload(fd --type f --hidden --follow --exclude .git .)\"; fi'" \
      \
      --bind 'enter:become(if [[ "{1}" == *:*:* ]]; then echo {1} | cut -d: -f1; else echo {1}; fi)'
  )"

  [[ -n "$ret" ]] && LBUFFER+="${(q)ret}"
}